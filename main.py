import sys
import asyncio
from datetime import datetime
from loguru import logger

from aiogram import Bot, Dispatcher
from aiogram.filters import CommandStart, Command
from aiogram.types import Message, CallbackQuery
from aiogram.enums import ParseMode, ChatAction
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.client.default import DefaultBotProperties

from config import BOT_TOKEN, VOX_TOKEN
from keyboards import main_menu, get_name_keyboard
from vox_executable import process_user_nickname, process_user_nicknames
from db.User import User
from vox.asyncapi import AsyncVoxAPI
from translations.get_phrase import get_phrase
from utils.get_user_info import get_current_username, get_language
from utils.login_requied import only_registered
from utils.zodiac import get_zodiac_sign
from inline_daily_prediction import router as inline_router, VoxMiddleware

# –ó–∞–≥—Ä—É–∂–∞–µ–º –ø—Ä–æ–º–ø—Ç—ã
from prompts import *


# FSM —Å–æ—Å—Ç–æ—è–Ω–∏—è
class BotStates(StatesGroup):
    waiting_for_question = State()
    waiting_for_yes_no_question = State()
    waiting_for_comp_nick = State()
    waiting_for_qualities_nick = State()
    waiting_for_name = State()
    waiting_for_birth_date = State()


# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞ —Å FSM
bot = None
vox = None
storage = MemoryStorage()
dp = Dispatcher(storage=storage)
logger.remove()
logger.add(sys.stdout, format="{time} {level} {message}", level="INFO", colorize=True)


@dp.message(CommandStart())
async def start_handler(message: Message, state: FSMContext):
    assert message.from_user
    user, created = await User.aio_get_or_create(
        telegram_user_id=message.from_user.id, telegram_chat_id=message.chat.id
    )
    nickname = message.from_user.username
    full_name = message.from_user.full_name

    if created:
        # –°–æ–∑–¥–∞–ª–∏ => –Ω–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å - –Ω–∞—á–∏–Ω–∞–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é
        await message.answer(
            get_phrase(
                phrase_tag="registration_welcome", language=get_language(message)
            )
        )
        await message.answer(
            get_phrase(phrase_tag="ask_name", language=get_language(message)),
            reply_markup=get_name_keyboard(nickname, full_name),
        )
        await state.set_state(BotStates.waiting_for_name)
    else:
        # –£–∂–µ –±—ã–ª–æ —Å–æ–∑–¥–∞–Ω–æ => —Å—Ç–∞—Ä—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
        if user.name and user.birth_date:
            # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω
            await message.answer(
                get_phrase(phrase_tag="welcome_back", language=get_language(message))
            )

            # –ü–æ–ª—É—á–∞–µ–º –∑–Ω–∞–∫ –∑–æ–¥–∏–∞–∫–∞
            zodiac_sign = (
                get_phrase(phrase_tag=user.zodiac_sign, language=get_language(message))
                if user.zodiac_sign
                else "–ù–µ —É–∫–∞–∑–∞–Ω"
            )

            await message.answer(
                get_phrase(phrase_tag="menu", language=get_language(message))
                .replace("{nickname}", nickname or user.name)
                .replace("{zodiac_sign}", zodiac_sign),
                reply_markup=main_menu,
            )
        else:
            # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –µ—Å—Ç—å –≤ –ë–î, –Ω–æ –Ω–µ –∑–∞–≤–µ—Ä—à–∏–ª —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é
            await message.answer(
                get_phrase(phrase_tag="ask_name", language=get_language(message)),
                reply_markup=get_name_keyboard(nickname, full_name),
            )
            await state.set_state(BotStates.waiting_for_name)


@dp.callback_query(
    lambda c: c.data
    in ["answers", "yes_no", "compatibility", "qualities", "prediction"]
)
async def handle_callback_query(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    nickname = get_current_username(callback)
    if not nickname:
        await callback.message.answer(
            get_phrase(phrase_tag="nickname_error", language=get_language(callback))
        )
        return

    if callback.data == "answers":
        await state.set_state(BotStates.waiting_for_question)
        await callback.message.answer("üîÆ –ó–∞–¥–∞–π—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å:")
    elif callback.data == "yes_no":
        await state.set_state(BotStates.waiting_for_yes_no_question)
        await callback.message.answer("üîÆ –ó–∞–¥–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å –¥–ª—è –î–∞/–ù–µ—Ç:")
    elif callback.data == "compatibility":
        await state.set_state(BotStates.waiting_for_comp_nick)
        await callback.message.answer(
            "üîÆ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞–∫–∫–∞—É–Ω—Ç –¥—Ä—É–≥–æ–≥–æ —á–µ–ª–æ–≤–µ–∫–∞ (@nickname):"
        )
    elif callback.data == "qualities":
        await state.set_state(BotStates.waiting_for_qualities_nick)
        await callback.message.answer(
            "üîÆ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞–∫–∫–∞—É–Ω—Ç –¥—Ä—É–≥–æ–≥–æ —á–µ–ª–æ–≤–µ–∫–∞ (@nickname):"
        )
    elif callback.data == "prediction":
        # –ü—Ä—è–º–æ–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –±–µ–∑ –¥–æ–ø. –≤–≤–æ–¥–∞
        loading = await callback.message.answer(
            get_phrase(phrase_tag="wait_vox_answer", language=get_language(callback))
        )
        await callback.message.bot.send_chat_action(
            callback.message.chat.id, ChatAction.TYPING
        )
        try:
            report = await process_user_nickname(vox, nickname, prediction_prompt)
            if report:
                await loading.edit_text(report, parse_mode=ParseMode.MARKDOWN)
            else:
                await loading.edit_text(
                    "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
                )
        except Exception as e:
            logger.exception(e)
            await loading.edit_text(
                get_phrase(
                    phrase_tag="processed_error", language=get_language(callback)
                )
            )


@dp.callback_query(lambda c: c.data.startswith("name_"))
async def handle_name_callback(callback: CallbackQuery, state: FSMContext):
    await callback.answer()

    if callback.data == "name_skip":
        name = "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å"
    else:
        name = callback.data.replace("name_", "")

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–º—è –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
    await state.update_data(name=name)

    # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –∑–∞–ø—Ä–æ—Å—É –¥–∞—Ç—ã —Ä–æ–∂–¥–µ–Ω–∏—è
    await callback.message.answer(
        get_phrase(phrase_tag="ask_birth_date", language=get_language(callback))
    )
    await state.set_state(BotStates.waiting_for_birth_date)


@dp.message(BotStates.waiting_for_name)
async def process_name_input(message: Message, state: FSMContext):
    # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–≤–µ–ª –∏–º—è —Ç–µ–∫—Å—Ç–æ–º
    name = message.text.strip()
    if len(name) > 50:
        await message.answer("–ò–º—è —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∫–æ—Ä–æ—á–µ.")
        return

    await state.update_data(name=name)
    await message.answer(
        get_phrase(phrase_tag="ask_birth_date", language=get_language(message))
    )
    await state.set_state(BotStates.waiting_for_birth_date)


@dp.message(BotStates.waiting_for_birth_date)
async def process_birth_date(message: Message, state: FSMContext):
    try:
        # –ü–∞—Ä—Å–∏–º –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì
        birth_date = datetime.strptime(message.text.strip(), "%d.%m.%Y").date()

        # –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–µ –∏–º—è
        data = await state.get_data()
        name = data.get("name", "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å")

        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∑–Ω–∞–∫ –∑–æ–¥–∏–∞–∫–∞ (–ø–æ–ª—É—á–∞–µ–º —Ç–µ–≥)
        zodiac_tag = get_zodiac_sign(birth_date)

        # –ü–æ–ª—É—á–∞–µ–º –ø–µ—Ä–µ–≤–æ–¥ –∑–Ω–∞–∫–∞ –∑–æ–¥–∏–∞–∫–∞
        zodiac_sign = get_phrase(phrase_tag=zodiac_tag, language=get_language(message))

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –ë–î
        user = await User.aio_get(telegram_user_id=message.from_user.id)
        user.name = name
        user.birth_date = birth_date
        user.zodiac_sign = zodiac_tag  # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–≥, –∞ –Ω–µ –ø–µ—Ä–µ–≤–æ–¥
        await user.aio_save()

        # –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        await state.clear()

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
        await message.answer(
            get_phrase(
                phrase_tag="registration_complete", language=get_language(message)
            ).replace("{zodiac_sign}", zodiac_sign)
        )

        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
        nickname = name
        await message.answer(
            get_phrase(phrase_tag="menu", language=get_language(message))
            .replace("{nickname}", nickname)
            .replace("{zodiac_sign}", zodiac_sign),
            reply_markup=main_menu,
        )

    except ValueError:
        await message.answer(
            "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç –î–î.–ú–ú.–ì–ì–ì–ì (–Ω–∞–ø—Ä–∏–º–µ—Ä, 15.03.1990)"
        )
    except Exception as e:
        logger.exception(e)
        await message.answer(
            "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
        )


@dp.message(BotStates.waiting_for_question)
async def process_question(message: Message, state: FSMContext):
    user_nick = get_current_username(message)
    question = message.text.strip()
    await state.clear()
    loading = await message.answer(
        get_phrase(phrase_tag="wait_vox_answer", language=get_language(message))
    )
    await message.bot.send_chat_action(message.chat.id, ChatAction.TYPING)
    try:
        prompt = f"–í–æ–ø—Ä–æ—Å: {question}" + answers_prompt
        report = await process_user_nickname(vox, user_nick, prompt)
        if report:
            await loading.edit_text(report, parse_mode=ParseMode.MARKDOWN)
        else:
            await loading.edit_text(
                "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            )
    except Exception as e:
        logger.exception(e)
        await loading.edit_text(
            get_phrase(phrase_tag="processed_error", language=get_language(message))
        )


@dp.message(BotStates.waiting_for_yes_no_question)
async def process_yes_no(message: Message, state: FSMContext):
    user_nick = get_current_username(message)
    question = message.text.strip()
    await state.clear()
    loading = await message.answer(
        get_phrase(phrase_tag="wait_vox_answer", language=get_language(message))
    )
    await message.bot.send_chat_action(message.chat.id, ChatAction.TYPING)
    try:
        prompt = f"–í–æ–ø—Ä–æ—Å: {question}" + yes_no_prompt
        report = await process_user_nickname(vox, user_nick, prompt)
        if report:
            await loading.edit_text(report, parse_mode=ParseMode.MARKDOWN)
        else:
            await loading.edit_text(
                "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            )
    except Exception as e:
        logger.exception(e)
        await loading.edit_text(
            get_phrase(phrase_tag="processed_error", language=get_language(message))
        )


@dp.message(BotStates.waiting_for_comp_nick)
async def process_compatibility(message: Message, state: FSMContext):
    user_nick = get_current_username(message)
    target = message.text.strip()
    if not target.startswith("@"):
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞–∫–∫–∞—É–Ω—Ç –≤–∏–¥–∞ @nickname.")
        return
    if target[1:] == user_nick:
        await message.answer(
            "–ù–µ–ª—å–∑—è —É–∫–∞–∑–∞—Ç—å —Å–≤–æ–π –∂–µ –Ω–∏–∫. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞–∫–∫–∞—É–Ω—Ç –¥—Ä—É–≥–æ–≥–æ —á–µ–ª–æ–≤–µ–∫–∞ –≤–∏–¥–∞ @nickname."
        )
        return
    await state.clear()
    loading = await message.answer(
        get_phrase(phrase_tag="wait_vox_answer", language=get_language(message))
    )
    await message.bot.send_chat_action(message.chat.id, ChatAction.TYPING)
    try:
        report = await process_user_nicknames(
            vox, user_nick, target[1:], compatibility_prompt
        )
        if report:
            await loading.edit_text(report, parse_mode=ParseMode.MARKDOWN)
        else:
            await loading.edit_text(
                "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            )
    except Exception as e:
        logger.exception(e)
        await loading.edit_text(
            get_phrase(phrase_tag="processed_error", language=get_language(message))
        )


@dp.message(BotStates.waiting_for_qualities_nick)
async def process_qualities(message: Message, state: FSMContext):
    user_nick = get_current_username(message)
    target = message.text.strip()
    if not target.startswith("@"):
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞–∫–∫–∞—É–Ω—Ç –≤–∏–¥–∞ @nickname.")
        return
    if target[1:] == user_nick:
        await message.answer(
            "–ù–µ–ª—å–∑—è —É–∫–∞–∑–∞—Ç—å —Å–≤–æ–π –∂–µ –Ω–∏–∫. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞–∫–∫–∞—É–Ω—Ç –¥—Ä—É–≥–æ–≥–æ —á–µ–ª–æ–≤–µ–∫–∞ –≤–∏–¥–∞ @nickname."
        )
        return
    await state.clear()
    loading = await message.answer(
        get_phrase(phrase_tag="wait_vox_answer", language=get_language(message))
    )
    await message.bot.send_chat_action(message.chat.id, ChatAction.TYPING)
    try:
        target_qualities = await process_user_nickname(
            vox, target[1:], qualities_prompt["people_qualities"]
        )  ## –ø–æ–ª—É—á–∞–µ–º –∫–∞—á–µ—Å—Ç–≤–∞ target'–∞
        if target_qualities:
            report = await process_user_nicknames(
                vox,
                user_nick,
                target[1:],
                qualities_prompt["tips"].replace("{info}", target_qualities),
            )
            if report:
                await loading.edit_text(report, parse_mode=ParseMode.MARKDOWN)
            else:
                await loading.edit_text(
                    "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
                )
        else:
            await loading.edit_text(
                "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            )
        # report = await process_user_nicknames(
        #     vox, user_nick, target[1:], qualities_prompt
        # )
        # if report:
        #     await loading.edit_text(report, parse_mode=ParseMode.MARKDOWN)
        # else:
        #     await loading.edit_text(
        #         "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        #     )
    except Exception as e:
        logger.exception(e)
        await loading.edit_text(
            get_phrase(phrase_tag="processed_error", language=get_language(message))
        )


@dp.message()
async def fallback(message: Message):
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é.")


async def main():
    global bot, vox
    if not BOT_TOKEN:
        logger.error("BOT_TOKEN –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –±–æ—Ç–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π inline —Ä–µ–∂–∏–º–∞
    bot = Bot(
        token=BOT_TOKEN,
        default=DefaultBotProperties(parse_mode=ParseMode.MARKDOWN)
    )
    vox = AsyncVoxAPI(token=VOX_TOKEN)
    
    # –î–æ–±–∞–≤–ª—è–µ–º middleware –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ vox –≤ inline —Ö–µ–Ω–¥–ª–µ—Ä—ã
    inline_router.inline_query.middleware(VoxMiddleware(vox))
    inline_router.callback_query.middleware(VoxMiddleware(vox))
    
    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º inline —Ö–µ–Ω–¥–ª–µ—Ä—ã –≤ –≥–ª–æ–±–∞–ª—å–Ω—ã–π –¥–∏—Å–ø–µ—Ç—á–µ—Ä
    dp.include_router(inline_router)
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞
    logger.info(f"–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –Ω–∞ {bot.id}")
    await dp.start_polling(bot, allowed_updates=dp.resolve_used_update_types())


if __name__ == "__main__":
    asyncio.run(main())
